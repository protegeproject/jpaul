// TestSetFactory.java, created Sun Aug 14 15:37:55 2005 by salcianu
// Copyright (C) 2005 Alexandru Salcianu <salcianu@alum.mit.edu>
// Licensed under the Modified BSD Licence; see COPYING for details.
package jpaul.DataStructs;

import java.util.Set;
import java.util.HashSet;
import java.util.Collection;
import java.util.List;
import java.util.LinkedList;
import java.util.Iterator;

import java.util.Random;

import jpaul.Misc.Function;
import jpaul.Misc.UComp;

import junit.framework.TestCase;
import junit.framework.Test;
import junit.framework.TestSuite;

/**
 * <code>TestSetFactory</code> contains regression tests for our set
 * factories.  The test methodology consists of generating long chains
 * of random set operations (add, remove, clone, etc) and run them in
 * parallel on sets generated by (1) a trusted set factory
 * (<code>HashSetFactory</code>) and (2) the set factory under test.
 * At each step we check that the results are the same.
 *
 * <p>
 * At each point we maintain two lists of generated sets (one list
 * for each factory).  Clone adds a new set to a list; having a list
 * of sets instead of only one set allows us to catch mysterious
 * representation sharing bugs.
 *
 * <p>
 * If you develop a new set factory, you should edit this file to
 * add some tests for it.
 *
 * @see SetFactory
 * 
 * @author  Alexandru Salcianu - salcianu@alum.mit.edu
 * @version $Id: TestSetFactory.java,v 1.7 2006/03/14 02:29:32 salcianu Exp $ */
public class TestSetFactory extends TestCase {
    
    public static Test suite() {
	return new TestSuite(TestSetFactory.class);
    }


    public void testArraySet() {
	System.out.println("Tests for ArraySet");

	fillUniverse();

	Set randomSet = new HashSet();
	Collection randomColl = new LinkedList();
	
	for(int i = 0; i <= 100; i++) {
	    System.out.print(".");
	    Object o = randomElem();
	    randomSet.add(o);
	    randomColl.add(o);
	    if(i % 10 == 0) {
		System.out.print("*");
		Set setFromSet = new ArraySet(randomSet);
		Set setFromListSet = new ArraySet(new LinkedList(randomSet), true);
		Set setFromColl = new ArraySet(randomColl, false);
		assert setFromSet.equals(randomSet) : "constructor ArraySet(Set) is broken";
		assert setFromListSet.equals(randomSet) : "constructor ArraySet(Collection,true) is broken";
		assert setFromColl.equals(randomSet) : "constructor ArraySet(Collection) is broken: " +
		    "randomColl = " + randomColl + "\n" +
		    "setFromColl = " + setFromColl + "\n" +
		    "randomSet = " + randomSet;
		assert setFromSet.equals(setFromListSet) : "strange: wrong ArraySet.iterator()?";
		assert setFromListSet.equals(setFromColl) : "strange: wrong ArraySet.iterator()?";
		assert setFromColl.equals(setFromSet) : "strange: wrong ArraySet.iterator()?";
	    }
	}
	System.out.println();
    }


    public void test() {
	checkProbs();

	fillUniverse();

	check(SetFacts.hash(), SetFacts.tree(new UComp()),
	      "SetFacts.tree(new UComp())");
	
	check(SetFacts.hash(), SetFacts.noCompTree(),
	      "SetFacts.noCompTree()");

	check(SetFacts.hash(), SetFacts.cow(SetFacts.hash()),
	      "SetFacts.cow(SetFacts.hash())");

	check(SetFacts.hash(), SetFacts.cow(SetFacts.tree(new UComp())),
	      "SetFacts.cow(SetFacts.tree(new UComp()))");

	check(SetFacts.hash(), SetFacts.cow(SetFacts.noCompTree()),
	      "SetFacts.cow(SetFacts.noCompTree())");
    }


    private void check(SetFactory refFact, SetFactory testFact, String name) {
	System.out.println("Tests for " + name);
	check(refFact, testFact);
    }

    private void check(SetFactory refFact, SetFactory testFact) {
	for(int i = 0; i < NB_TESTS; i++) {
	    oneTest(refFact, testFact);
	}
    }
    

    // trying to have a "real" pseudo-random generator
    private Random random = new Random(System.currentTimeMillis());

    private int UNIVERSE_SIZE = 40;
    private Object[] universe;

    private int NB_TESTS = 2;  // numbers of random tests
    private int NB_OPERS = 5000; // random operations in each tests

    
    private void fillUniverse() {
	universe = new Object[UNIVERSE_SIZE];
	for(int i = 0; i < UNIVERSE_SIZE; i++) {
	    universe[i] = new Integer(i);
	}
    }


    private static abstract class SetOper extends Function<Set,Object> {
    	//empty
    }

    private static class AddOper extends SetOper {
	public AddOper(Object elem) {
	    this.elem = elem;
	}
	private final Object elem;
	public Boolean f(Set s) {
	    return new Boolean(s.add(elem));
	}
	public String toString() {
	    return "add " + elem;
	}
    }

    private static class AddAllOper extends SetOper {
	public AddAllOper(Collection elems) {
	    this.elems = elems;
	}
	private final Collection elems;
	public Boolean f(Set s) {
	    return new Boolean(s.addAll(elems));
	}
	public String toString() {
	    return "addAll " + elems;
	}
    }


    private static class RemoveOper extends SetOper {
	public RemoveOper(Object elem) {
	    this.elem = elem;
	}
	private final Object elem;
	public Boolean f(Set s) {
	    return new Boolean(s.remove(elem));
	}
	public String toString() {
	    return "remove " + elem;
	}
    }

    private static class RemoveAllOper extends SetOper {
	public RemoveAllOper(Collection elems) {
	    this.elems = elems;
	}
	private final Collection elems;
	public Boolean f(Set s) {
	    return new Boolean(s.removeAll(elems));
	}
	public String toString() {
	    return "removeAll " + elems;
	}
    }

    private static class ContainsOper extends SetOper {
	public ContainsOper(Object elem) {
	    this.elem = elem;
	}
	private final Object elem;
	public Boolean f(Set s) {
	    return new Boolean(s.contains(elem));
	}
	public String toString() {
	    return "contains " + elem;
	}
    }

    private static class SizeOper extends SetOper {
	public SizeOper() { /*empty*/ }
	public Integer f(Set s) {
	    return new Integer(s.size());
	}
	public String toString() {
	    return "size ";
	}
    }

    private static class IsEmptyOper extends SetOper {
	public IsEmptyOper() { /*empty*/ }
	public Boolean f(Set s) {
	    return new Boolean(s.isEmpty());
	}
	public String toString() {
	    return "isEmpty ";
	}
    }

    private static class CloneOper extends SetOper {
	public CloneOper(Function<Object,SetFactory> setFactProv) {
	    this.setFactProv = setFactProv;
	}
	private final Function<Object,SetFactory> setFactProv;
	public Set f(Set s) {
	    return setFactProv.f(null).create(s);
	}
	public String toString() {
	    return "clone ";
	}
    }

    private static class ClearOper extends SetOper {
	public ClearOper() { /*empty*/ }
	public Object f(Set s) {
	    s.clear();
	    return null;
	}
	public String toString() {
	    return "clear ";
	}
    }

    // Probabilities of each randomly-generated operation (adds are
    // clearly more frequent in practice than clear and we want to
    // take this into account in our randomly generated workloads.
    //
    // add, addAll, remove, removeAll, contains, size, isEmpty, clone, clear
    private static final int[] probs = new int[]{50, 5, 10, 5, 15, 5, 5, 3, 2};

    private void checkProbs() {
	int total = 0;
	for(int i = 0; i < probs.length; i++)
	    total += probs[i];
	assert total == 100 : "total probs != 100 ...";
    }

    private int getRandomOperIndex() {
	int k = random.nextInt(100);
	int prob = 0;
	for(int i = 0; i < probs.length; i++) {
	    prob += probs[i];
	    if(k < prob) {
		return i;
	    }
	}
	throw new Error("should not happen");
    }


    private Pair<Integer,SetOper> getSetOper(Function<Object,SetFactory> setFactProv, List<Set> sets) {
	int setIndex = random.nextInt(sets.size());
	Set set = sets.get(setIndex);
	SetOper oper = null;
	int opIndex  = getRandomOperIndex();
	switch(opIndex) {
	case 0:
	    oper = getAddOper(set);
	    break;
	case 1:
	    oper = getAddAllOper(set);
	    break;
	case 2:
	    oper = getRemoveOper(set);
	    break;
	case 3:
	    oper = getRemoveAllOper(set);
	    break;
	case 4:
	    oper = getContainsOper(set);
	    break;
	case 5:
	    oper = new SizeOper();
	    break;
	case 6:
	    oper = new IsEmptyOper();
	    break;
	case 7:
	    oper = new CloneOper(setFactProv);
	    break;
	case 8:
	    oper = new ClearOper();
	    break;
	default:
	    assert false : "unknown operation #" + opIndex;
	}
	return new Pair<Integer,SetOper>(new Integer(setIndex), oper);
    }


    private Object randomElem() {
	return universe[random.nextInt(universe.length)];
    }

    private Collection randomElems() {
	Collection coll = new LinkedList();
	int collSize = random.nextInt(universe.length / 2);
	for(int i = 0; i < collSize; i++) {
	    coll.add(randomElem());
	}
	return coll;
    }


    private SetOper getAddOper(Set set) {
	return new AddOper(randomElem());
    }

    private SetOper getAddAllOper(Set set) {
	return new AddAllOper(randomElems());
    }

    private SetOper getRemoveOper(Set set) {
	return new RemoveOper(randomElem());
    }

    private SetOper getRemoveAllOper(Set set) {
	return new RemoveAllOper(randomElems());
    }

    private SetOper getContainsOper(Set set) {
	return new ContainsOper(randomElem());
    }


    private List<Pair<Integer,SetOper>> opers = null;
    private List<Set> refSets;
    private List<Set> testSets;
    private SetFactory currFact = null;
    
    private void oneTest(final SetFactory refFact, final SetFactory testFact) {
	opers = new LinkedList<Pair<Integer,SetOper>>();

	refSets = new LinkedList<Set>();
	refSets.add((Set) refFact.create());
	testSets = new LinkedList<Set>();
	testSets.add((Set) testFact.create());

	final Function<Object,SetFactory> setFactProv = new Function<Object,SetFactory>() {
	    public SetFactory f(Object obj) {
		return currFact;
	    }
	};

	checkEqualSets();

	for(int i = 0; i < NB_OPERS; i++) {
	    Pair<Integer,SetOper> setOper = getSetOper(setFactProv, refSets);
	    opers.add(setOper);

	    currFact = refFact;
	    Object refResult = executeSetOper(setOper, refSets);
	    System.out.println(i + "\tExecute " + setOper.right + " on set #" + setOper.left + " -> " + refResult);

	    currFact = testFact;
	    Object testResult = executeSetOper(setOper, testSets);

	    assert DSUtil.checkEq(refResult, testResult) : "different results after " + opers;
	    checkEqualSets();
	}

	System.out.println("SUCCESS!");
    }


    private Object executeSetOper(Pair<Integer,SetOper> setOper, List<Set> sets) {
	Set set = sets.get(setOper.left.intValue());
	Object result = setOper.right.f(set);
	if((result != null) && (result instanceof Set)) {
	    sets.add((Set) result);
	}
	return result;
    }

    private void checkEqualSets() {
	assert refSets.size() == testSets.size() : "different #s of sets after " + opers;
	Iterator<Set> refIt  = refSets.iterator();
	Iterator<Set> testIt = testSets.iterator();
	int k = 0;
	while(refIt.hasNext()) {
	    Set refSet  = refIt.next();
	    Set testSet = testIt.next();
	    assert
		refSet.hashCode() == testSet.hashCode() : 
		"different hashCode's for set #" + k + " after " + opers;
		
	    assert refSet.equals(testSet) : "different set #" + k + " after " + opers;
	    k++;
	}
    }    
}
